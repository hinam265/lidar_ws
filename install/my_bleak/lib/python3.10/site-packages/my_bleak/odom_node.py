import rclpy
from rclpy.node import Node
from nav_msgs.msg import Odometry
from sensor_msgs.msg import Imu

from geometry_msgs.msg import Quaternion
from geometry_msgs.msg import TransformStamped

class OdometryPublisher(Node):
    def __init__(self):
        super().__init__('odometry_publisher')

        # Subcribe to the IMU data topic
        #self.imu_sub = self.create_subscription(
            #Imu,
            #'imu_data',
            #self.imu_callback,
            #10)

        # Create a publisher for the odometry data.
        self.odom_pub = self.create_publisher(
                Odometry,
                'odom',
                10)

        # Create a publisher for the transform data.
        self.tf_pub = self.create_publisher(
                TransformStamped,
                '/tf',
                10)

        # Initialize the odometry data.
        self.x = 0.0
        self.y = 0.0
        self.th = 0.0

        # Set the robot's velocities
        self.vx = 0.1
        self.vy = -0.1
        self.vth = 0.1

        # Initialize the last time stamp.
        self.last_time = self.get_clock().now().to_msg() 

        # Initialize the odometry data.
        self.odom = Odometry()
        self.odom.header.frame_id = 'odom'

    def publish_odometry(self):
        # Compute the odometry since the last time stamp.
        current_time = self.get_clock().now().to_msg()
        dt = (current_time - self.last_time).seconds

        delta_x = (self.vx * cos(self.th) - self.vy * sin(self.th)) * dt
        delta_y = (self.vx * sin(self.th) + self.vy * cos(self.th))*dt
        delta_th = self.vth * dt 

        # Update the odometry data
        self.x += delta_x
        self.y += delta_y
        self.th += delta_th

        # Create a quaternion from the yaw angle
        odom_quat =  Quaternion()
        odom_quat.x = 0.0
        odom_quat.y = 0.0
        odom_quat.z = sin(self.th / 2.0)
        odom_quat.w = cos(self.th / 2.0)

        # Create an odometry message
        odom_msg = Odometry()
        odom_msg.header.stamp = current_time
        odom_msg.header.frame_id = 'odom'
        odom_msg.child_frame_id = 'base_link'

        odom_msg.pose.pose.position.x = self.x
        odom_msg.pose.pose.position.y = self.y
        odom_msg.pose.pose.position.z = 0.0
        odom_msg.pose.pose.orientation = odom_quat

        odom_msg.twist.twist.linear.x = self.vx
        odom_msg.twist.twist.linear.y = self.vy
        odom_msg.twist.twist.linear.z = 0.0 
        odom_msg.twist.twist.angular.x = 0.0
        odom_msg.twist.twist.angular.y = 0.0
        odom_msg.twist.twist.angular.z = self.vth

        # Publish the odometry message
        self.odom_pub.publish(odom_msg)

        # Create a transform message
        tf_msg = TransformStamped()
        tf_msg.header.stamp = current_time
        tf_msg.header.frame_id = 'odom'
        tf_msg.child_frame_id = 'base_link'

        tf_msg.transform.translation.x = self.x
        tf_msg.transform.translation.y = self.y
        tf_msg.transform.translation.z = 0.0
        tf_msg.transform.rotation = odom_quat

        # Publish the transform message
        self.tf_pub.publish(tf_msg)

        # Update the last time stamp
        self.last_time = current_time

def main(args=None):
    rclpy.init()
    op = OdometryPublisher()
    
    # Spin the Node
    rclpy.spin(op)

    # Destroy the Node
    rclpy.shutdown()

if __name__ == '__main__':
    main()
